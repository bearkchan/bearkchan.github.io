<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java集合的使用 - BK - Coding the world</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Bearkchan" /><meta name="description" content="1. Java容器有哪些 Java容器可以分为三类：数组、Collection和Map，它们的特点有： 数组：长度确定，元素类型确定。 Collect" /><meta name="keywords" content="bearkchan, java, php" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://bearkchan.github.io/post/java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/002-%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.cb68f97bc9cece255d217346d970e3c62623408634e500c330a62fadabbbe77c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java集合的使用" />
<meta property="og:description" content="1. Java容器有哪些 Java容器可以分为三类：数组、Collection和Map，它们的特点有： 数组：长度确定，元素类型确定。 Collect" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bearkchan.github.io/post/java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/002-%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-11T00:29:44&#43;08:00" />
<meta property="article:modified_time" content="2020-03-11T00:29:44&#43;08:00" />

<meta itemprop="name" content="Java集合的使用">
<meta itemprop="description" content="1. Java容器有哪些 Java容器可以分为三类：数组、Collection和Map，它们的特点有： 数组：长度确定，元素类型确定。 Collect"><meta itemprop="datePublished" content="2020-03-11T00:29:44&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-11T00:29:44&#43;08:00" />
<meta itemprop="wordCount" content="9716">
<meta itemprop="keywords" content="java,集合," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java集合的使用"/>
<meta name="twitter:description" content="1. Java容器有哪些 Java容器可以分为三类：数组、Collection和Map，它们的特点有： 数组：长度确定，元素类型确定。 Collect"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">BK&#39;s BLOG</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">BK&#39;s BLOG</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java集合的使用</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-11 </span>
        <div class="post-category">
            <a href="/categories/java/"> java </a>
            </div>
          <span class="more-meta"> 约 9716 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-java容器有哪些">1. Java容器有哪些</a></li>
        <li><a href="#2-collection的使用">2. Collection的使用</a>
          <ul>
            <li><a href="#21-collection接口常用的方法">2.1 Collection接口常用的方法</a></li>
            <li><a href="#22-集合和数组之间的转换">2.2 集合和数组之间的转换</a></li>
            <li><a href="#23-使用collection集合存储对象要求对象所属的类符合什么要求">2.3 使用Collection集合存储对象，要求对象所属的类符合什么要求？</a></li>
          </ul>
        </li>
        <li><a href="#3-iterator接口和foreach循环">3. Iterator接口和foreach循环</a>
          <ul>
            <li><a href="#31-遍历collection的两种方式">3.1 遍历Collection的两种方式</a></li>
            <li><a href="#32-javautilsiterator接口说明">3.2 java.utils.Iterator接口说明</a></li>
            <li><a href="#33-jdk50新特性---增强for循环foreach">3.3 jdk5.0新特性&mdash;增强for循环（foreach）</a></li>
          </ul>
        </li>
        <li><a href="#4-collection子接口list接口">4. Collection子接口：List接口</a>
          <ul>
            <li><a href="#41-list接口介绍">4.1 List接口介绍</a></li>
            <li><a href="#42-常用方法">4.2 常用方法</a></li>
            <li><a href="#43-arraylist源码分析">4.3 ⭐ArrayList源码分析</a></li>
            <li><a href="#44-linkedlist源码分析">4.4 LinkedList源码分析</a></li>
            <li><a href="#45-vector源码分析">4.5 Vector源码分析</a></li>
            <li><a href="#46-面试题arraylistlinkedlistvector三者的异同">4.6 面试题：ArrayList、LinkedList、Vector三者的异同？</a></li>
          </ul>
        </li>
        <li><a href="#5-collection子接口set接口">5. Collection子接口：Set接口</a>
          <ul>
            <li><a href="#51-set接口介绍">5.1 Set接口介绍</a></li>
            <li><a href="#52-元素添加过程以hashset为例">5.2 元素添加过程（以HashSet为例）</a></li>
            <li><a href="#53-存储对象所在类的要求">5.3 存储对象所在类的要求</a></li>
            <li><a href="#54-treeset使用细则">5.4 TreeSet使用细则</a></li>
            <li><a href="#55-hashset面试题">5.5 HashSet面试题</a></li>
          </ul>
        </li>
        <li><a href="#6-map的使用">6. Map的使用</a>
          <ul>
            <li><a href="#61-map接口介绍">6.1 Map接口介绍</a></li>
            <li><a href="#62-map涉及到的面试题">6.2 Map涉及到的面试题</a></li>
            <li><a href="#63-存储结构的理解">6.3 存储结构的理解</a></li>
            <li><a href="#64-map接口常用方法">6.4 Map接口常用方法</a></li>
            <li><a href="#65-遍历map的三种方式">6.5 遍历Map的三种方式</a></li>
            <li><a href="#66-hashmap的底层实现原理">6.6 HashMap的底层实现原理</a></li>
            <li><a href="#67-hashmap底层典型属性的说明">6.7 HashMap底层典型属性的说明</a></li>
            <li><a href="#68-linkedhashmap底层源码解析了解">6.8 LinkedHashMap底层源码解析（了解）</a></li>
            <li><a href="#69-treemap的使用">6.9 TreeMap的使用</a></li>
            <li><a href="#610-使用properties读取配置文件">6.10 使用Properties读取配置文件</a></li>
          </ul>
        </li>
        <li><a href="#7-collections的使用">7. Collections的使用</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-java容器有哪些">1. Java容器有哪些</h2>
<p>Java容器可以分为三类：数组、Collection和Map，它们的特点有：</p>
<ul>
<li><strong>数组</strong>：长度确定，元素类型确定。</li>
<li><strong>Collection</strong>：存放的单列数据，分为List和Set。
<ul>
<li>List：有序可重复数据（也被称为动态数组）</li>
<li>Set：无序不可重复数据</li>
</ul>
</li>
<li><strong>Map</strong>：存放的是key-value形式的双列数据。</li>
</ul>
<p>其中，Collection和Map统称为集合，集合框架如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">集合
<span class="p">|</span>--Collection
<span class="p">|</span>		<span class="p">|</span>--List
<span class="p">|</span>		<span class="p">|</span>		<span class="p">|</span>--ArrayList、LinkedList、Vector
<span class="p">|</span>		<span class="p">|</span>--Set
<span class="p">|</span>		<span class="p">|</span>		<span class="p">|</span>--HashSet、LinkedHashSet、TreeSet
<span class="p">|</span>--Map
<span class="p">|</span>		<span class="p">|</span>--HashMap、LinkedHashMap、TreeMap、HashTable、Properties
</code></pre></td></tr></table>
</div>
</div><h2 id="2-collection的使用">2. Collection的使用</h2>
<h3 id="21-collection接口常用的方法">2.1 Collection接口常用的方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">-</span> add(Object obj)
<span class="k">-</span> seize()：获取的是collection中元素的个数，而不是集合中数组的长度。
<span class="k">-</span> addAll(Collection col)
<span class="k">-</span> isEmpty()
<span class="k">-</span> clear()：清空集合，将所有元素设置为null

<span class="k">-</span> contains(Object obj)：是否包含obj，底部调用的是obj的equals()方法，将每一个add的对象作为形参放入obj的equals方法中进行比较。
<span class="k">-</span> contains(Collection col)：是否包含col中的所有元素。
<span class="k">-</span> remove(Object obj)：底部调用了obj的euqals方法
<span class="k">-</span> removeAll(Collcetion col)：求差集，求当前集合和col的差集，去除当前集合中包含的所有的col的元素，并且重赋值给当前对象。
<span class="k">-</span> retianAll(Collection col)：求子集，求当前集合和col所共有的，并重新赋值给当前集合。
<span class="k">-</span> equals(Collection col)：判断当前集合和col所有的元素是否相等。如果是List，则必须所有元素的顺序一致。

<span class="k">-</span> hashCode()
<span class="k">-</span> toArray()：将集合转换为数组。
<span class="k">-</span> iterator()：返回Iterator接口实例，用于便利集合元素。
</code></pre></td></tr></table>
</div>
</div><h3 id="22-集合和数组之间的转换">2.2 集合和数组之间的转换</h3>
<ul>
<li>
<p>将集合转换为数组：使用集合的<code>toArray()</code>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;nihao&#34;</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;xiaomi&#34;</span><span class="o">,</span><span class="n">18</span><span class="o">));</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">objects</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>将数组转换为集合，使用Arrays工具类的<code>asList(T...)</code>方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]{</span><span class="s">&#34;AAA&#34;</span><span class="o">,</span><span class="s">&#34;BBB&#34;</span><span class="o">,</span><span class="s">&#34;CCC&#34;</span><span class="o">});</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list1</span><span class="o">);</span>

<span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list2</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">});</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list2</span><span class="o">);</span><span class="c1">//[[I@cb51256]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list2</span><span class="o">.</span><span class="na">size</span><span class="o">());</span><span class="c1">//1
</span><span class="c1"></span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list3</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">Integer</span><span class="o">[]{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">});</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list3</span><span class="o">);</span><span class="c1">//[1, 2, 3]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list3</span><span class="o">.</span><span class="na">size</span><span class="o">());</span><span class="c1">//3
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>⚠️：Arrays.asList(T&hellip; a)中a形参不能为基本数据类型，必须为包装类类型数组。</p>
<p>Arrays.asList(new int[]{1,2,3})将会转换为只包含一个元素的List集合。系统会默认将整个new int[]{1,2,3}当作是一个int[]类型的元素，而不是一个需要转换的数组，解决办法有：</p>
<ol>
<li>Arrays.asList(new Integer[]{1,2,3});</li>
<li>Arrays.asList(1,2,3);</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="23-使用collection集合存储对象要求对象所属的类符合什么要求">2.3 使用Collection集合存储对象，要求对象所属的类符合什么要求？</h3>
<p>向Collection接口的实现类添加对象obj的时候，要求obj所属的类重写了<code>equals()</code>方法。</p>
<h2 id="3-iterator接口和foreach循环">3. Iterator接口和foreach循环</h2>
<h3 id="31-遍历collection的两种方式">3.1 遍历Collection的两种方式</h3>
<ul>
<li>使用迭代器Iterator</li>
<li>foreach循环（或增强for循环）</li>
</ul>
<h3 id="32-javautilsiterator接口说明">3.2 java.utils.Iterator接口说明</h3>
<p>Iterator对象称为迭代器（设计模式的一种）,GOF给迭代器模式的定义是：提供一种方法访问一个容器（container）对象中各个元素，而又不需要暴露该对象的内部细节。迭代器模式就是为容器而生的。它主要用于<strong>遍历Collection集合中的元素。</strong></p>
<blockquote>
<p>迭代器不能用于Map。</p>
</blockquote>
<p>如何使用Iterator：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;nihao&#34;</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;xiaomi&#34;</span><span class="o">,</span><span class="n">18</span><span class="o">));</span>
<span class="c1">// 1. 通过集合的iterator()方法创建迭代器实例
</span><span class="c1"></span><span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="c1">// 2. 使用while循环，通过hasNext()方法判断是否还有下一个元素
</span><span class="c1"></span><span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
  <span class="c1">//3. 如果有，则使用next()方法将迭代器指向下一个元素，并且返回其元素值
</span><span class="c1"></span>  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代器的执行原理如下：</p>
<p><img src="http://cdn.bearkchan.top/image-20210120103616285.png" alt="image-20210120103616285"></p>
<blockquote>
<p>迭代器也可以通过<code>remove()</code>方法，在遍历的时候，删除当前位置的元素值。</p>
</blockquote>
<h3 id="33-jdk50新特性---增强for循环foreach">3.3 jdk5.0新特性&mdash;增强for循环（foreach）</h3>
<p>在jdk5.0之后新增了foreach循环，用于遍历集合和数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ArrayList</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;nihao&#34;</span><span class="o">);</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;xiaomi&#34;</span><span class="o">,</span><span class="n">18</span><span class="o">));</span>

<span class="k">for</span> <span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：其内部仍然调用的是迭代器方法。</p>
</blockquote>
<p>同时，在jdk8之后，我们可以直接使用迭代器的默认方法forEach()进行循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="4-collection子接口list接口">4. Collection子接口：List接口</h2>
<h3 id="41-list接口介绍">4.1 List接口介绍</h3>
<p>List接口是Collection的子接口，它存储数据的特点是：</p>
<ul>
<li>有序的</li>
<li>可重复的</li>
</ul>
<p>它的常用实现类包括：ArrayList、LinkedList、Vector等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown">List
|--ArrayList:List接口的主要实现类，线程不安全，效率高，底部使用object[]存储elementData
|--LinkedList:底部使用双向链表存储，对于频繁的插入、删除，效率比ArrayList高
|--Vector:古老实现类，java1.0出现，线程安全，效率低，底层使用objectp[]存储elementData
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>⭐List存储对象的要求：对象所在的类必须重写了equals()方法。</p>
</blockquote>
<h3 id="42-常用方法">4.2 常用方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">-</span> void add(int index, Object ele):在index位置插入ele元素
<span class="k">-</span> boolean addAll(int index, Collection eles):从index位置开始将eles中所有的元素添加进来
<span class="k">-</span> Object get(int index):获取指定index位置的元素
<span class="k">-</span> int indexOf(Object obj):返回obj在集合中首次出现的位置
<span class="k">-</span> int lastIndexOf(Object obj):返回obj在集合中最后出现的位置
<span class="k">-</span> Object remove(int index):移除指定index位置的元素，并返回该元素
<span class="k">-</span> Object set(int index, Object ele):设置指定index位置的元素为ele
<span class="k">-</span> List subList(int formIndex, int toIndex):返回从formIndex对toIndex位置的子集合[左闭右开]
</code></pre></td></tr></table>
</div>
</div><p>对上述方法的总结如下：</p>
<ul>
<li>
<p>增：add(Object obj)</p>
</li>
<li>
<p>删：remove(int index)  / remove(Object obj)</p>
<blockquote>
<p>如果remove方法的形参发生冲突的话，则会优先调用remove(int index)方法。</p>
</blockquote>
</li>
<li>
<p>改：set(int index, Object ele)</p>
</li>
<li>
<p>查：get(int index)</p>
</li>
<li>
<p>插：add(int index, Object obj)</p>
</li>
<li>
<p>长度：size()</p>
</li>
<li>
<p>遍历：1.Iterator迭代器；2.增强for循环；3.普通的循环</p>
</li>
</ul>
<h3 id="43-arraylist源码分析">4.3 ⭐ArrayList源码分析</h3>
<ul>
<li>
<p>JDK7的情况下：</p>
<p>ArrayList list = new ArrayList();// 底层创建了长度为10的Object[]数组elementData.</p>
<p>list.add(123);// elementData[0] = new Integer(123);</p>
<p>&hellip;</p>
<p>list.add(11);//如果此次添加导致底层elementData数组容量不够，则扩容。</p>
<p>默认情况下，扩容为原来的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<blockquote>
<p>总结：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)；</p>
<p>这样可以减少过多的扩容操作所带来的内存的消耗。</p>
</blockquote>
</li>
<li>
<p>JDK8的情况下：</p>
<p>ArrayList list = new ArrayList();// 底层Object[] elementData初始化为{},而不是直接创建数组。</p>
<p>list.add(123);// 第一次调用add()时，底层才创建长度为10的数组，并将数据123，添加到elementData的0号位置上。</p>
<p>&hellip;</p>
<p>后续的添加和扩容操作与jdk7一样。</p>
</li>
</ul>
<blockquote>
<p>总结：jdk7中的ArrayList的对象的创建类似于单例模式中的饿汉式，而djk8中的ArrayList的对象创建则像单例模式中的懒汉式，延迟了数组的创建，节省了内存。</p>
</blockquote>
<h3 id="44-linkedlist源码分析">4.4 LinkedList源码分析</h3>
<p>LinkedList list = new LinkedList();// 内部声明了Node类型的first和last属性，默认值为null</p>
<p>list.add(123); // 将123封装的Node中，创建了Node对象。</p>
<p>其中，Node的定义体现了LinkedList的双向链表的说法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">E</span> <span class="n">item</span><span class="o">;</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>

  <span class="n">Node</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="n">E</span> <span class="n">element</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="45-vector源码分析">4.5 Vector源码分析</h3>
<p>jdk7 和jdk8中通过Vector()构造器创建对象时，底层创建了长度为10的数组；</p>
<p>在扩容方面，默认扩容为原来数组长度的2倍。</p>
<h3 id="46-面试题arraylistlinkedlistvector三者的异同">4.6 面试题：ArrayList、LinkedList、Vector三者的异同？</h3>
<ul>
<li>相同点：三个类都是实现了List接口，存储数据的特点相同：存储有序的可重复的数据。</li>
<li>不同点：
<ul>
<li>ArrayList与Vector相比，Vector的默认扩容策略是原来的2倍，而ArrayList的扩容策略是原来的1.5倍。并且ArrayList是线程不安全的，效率高；而Vector是线程安全的，效率低。</li>
<li>ArrayList与LinkedList相比，LinkedList底层使用的是双向链表的方式存储数据，而ArrayList底层使用的是数组的方式存储数据。对于频繁的插入删除操作，LinkedList效率比ArrayList高。</li>
</ul>
</li>
</ul>
<h2 id="5-collection子接口set接口">5. Collection子接口：Set接口</h2>
<h3 id="51-set接口介绍">5.1 Set接口介绍</h3>
<p>Set是Collection的子接口，它存储数据的特点是：（以HashSet为例）</p>
<ul>
<li>无序的：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li>不可重复的：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。</li>
</ul>
<p>Set的实现类包括：HashSet、LinkedHashSet、TreeSet等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown">Set
|--HashSet:Set接口的主要实现类，线程不安全，可以存储null值
|--LinkedHashSet:HashSet的子类，在遍历内部数据时，可以按照添加的顺序读取。在添加数据的时候，每个数据还维护了两个引用，用于记录上一个数据和下一个数据的位置。
|--TreeSet:可以按照添加对象的指定属性进行排序，所有添加的对象必须属于同一个类
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>在开发中，Set使用的不是很多。</p>
</blockquote>
<h3 id="52-元素添加过程以hashset为例">5.2 元素添加过程（以HashSet为例）</h3>
<p>我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置）。判断数组此位置上是否已经有元素：</p>
<ul>
<li>如果此位置上没有其他元素，则元素a添加成功。<strong>&mdash;&mdash;&gt;情况1</strong></li>
<li>如果此位置上已经有其他元素b（或者以链表的形式存在的多个元素），则比较元素a和元素b的hash值：
<ul>
<li>如果hash值不同，则元素a添加成功.<strong>&mdash;&mdash;&ndash;&gt;情况2</strong></li>
<li>如果hash值相同，进而调用元素a所在类的equals()方法，与此位置上链表的所有元素进行比较：
<ul>
<li>如果equals()返回true，则元素a添加失败</li>
<li>如果equals()返回false，则元素a添加成功。<strong>&mdash;&mdash;&mdash;-&gt;情况3</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于添加的情况2和情况3而言：元素a与已经存在指定索引位置上数据以链表的形式存储。</p>
<p>Jdk7:元素a存放到数组中，指向原来的元素。</p>
<p>Jdk8:原来的元素在数组中，指向元素a。</p>
<p>总结：七上八下</p>
</blockquote>
<blockquote>
<p>⚠️HashSet的底层的存储结构：在jdk7中是数组+链表的结构。​</p>
</blockquote>
<h3 id="53-存储对象所在类的要求">5.3 存储对象所在类的要求</h3>
<ul>
<li>HashSet和LinkedHashSet：所在类需要重写hashCode()方法和equals()方法。且两个方法必须保证一致性，即hashCode()方法和equals()方法都要涉及到类的所有成员变量。</li>
<li>TreeSet：所在类以比较器作为判别标准：自然排序和定制排序。
<ul>
<li>自然排序：比较两个对象是否相同的标准：compareTo(Object obj)是否返回0。</li>
<li>定制排序：比较两个对象是否相同的标准：compare(Object obj1, Object obj2)是否返回true。</li>
</ul>
</li>
</ul>
<h3 id="54-treeset使用细则">5.4 TreeSet使用细则</h3>
<p>TreeSet在使用的时候需要遵守两个规则：</p>
<ul>
<li>向TreeSet中添加数据的时候，必须是相同类的对象。</li>
<li>要使用两种排序方式：自然排序或者是定制排序。</li>
</ul>
<p>自然排序demo:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Person.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Person</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 根据年龄比较大小
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
    <span class="o">}</span>
  
  <span class="c1">// ...getter and setter、tostring...
</span><span class="c1"></span><span class="o">}</span>


<span class="c1">// test.java
</span><span class="c1"></span><span class="n">TreeSet</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&lt;&gt;();</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;xiaomi&#34;</span><span class="o">,</span> <span class="n">43</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;zhangsan&#34;</span><span class="o">,</span> <span class="n">23</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;lisi&#34;</span><span class="o">,</span> <span class="n">73</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">Person<span class="o">{</span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;zhangsan&#39;</span>, <span class="nv">age</span><span class="o">=</span>23<span class="o">}</span>
Person<span class="o">{</span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;xiaomi&#39;</span>, <span class="nv">age</span><span class="o">=</span>43<span class="o">}</span>
Person<span class="o">{</span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;lisi&#39;</span>, <span class="nv">age</span><span class="o">=</span>73<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>定制排序demo:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 定制排序
</span><span class="c1"></span><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">comparator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Person</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Person</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">getAge</span><span class="o">(),</span> <span class="n">o2</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">};</span>
<span class="c1">// 使用有参构造器声明比较器
</span><span class="c1"></span><span class="n">TreeSet</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&lt;&gt;(</span><span class="n">comparator</span><span class="o">);</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;xiaomi&#34;</span><span class="o">,</span> <span class="n">43</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;zhangsan&#34;</span><span class="o">,</span> <span class="n">23</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;lisi&#34;</span><span class="o">,</span> <span class="n">73</span><span class="o">));</span>
<span class="n">people</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="55-hashset面试题">5.5 HashSet面试题</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">HashSet</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
<span class="n">Animal</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;AA&#34;</span><span class="o">);</span>
<span class="n">Animal</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">(</span><span class="n">1002</span><span class="o">,</span> <span class="s">&#34;BB&#34;</span><span class="o">);</span>
<span class="n">animals</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>
<span class="n">animals</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a2</span><span class="o">);</span>
<span class="c1">// [Animal{id=1002, name=&#39;BB&#39;}, Animal{id=1001, name=&#39;AA&#39;}]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span>

<span class="n">a1</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">&#34;CC&#34;</span><span class="o">;</span>
<span class="n">animals</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>
<span class="c1">// 1⃣️[Animal{id=1002, name=&#39;BB&#39;}, Animal{id=1001, name=&#39;CC&#39;}]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span>

<span class="n">animals</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Animal</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;CC&#34;</span><span class="o">));</span>
<span class="c1">// 2⃣️[Animal{id=1002, name=&#39;BB&#39;}, Animal{id=1001, name=&#39;CC&#39;}, Animal{id=1001, name=&#39;CC&#39;}]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span>
<span class="n">animals</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Animal</span><span class="o">(</span><span class="n">1001</span><span class="o">,</span> <span class="s">&#34;AA&#34;</span><span class="o">));</span>
<span class="c1">// 3⃣️[Animal{id=1002, name=&#39;BB&#39;}, Animal{id=1001, name=&#39;CC&#39;}, Animal{id=1001, name=&#39;CC&#39;}, Animal{id=1001, name=&#39;AA&#39;}]
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>1⃣️：当调用animals.remove(a1)时，首先根据现在a1的hashCode()方法计算哈希值，而a1的name属性已经发生变化，所以其哈希值也发生了变化，随后根据哈希值所求的在底层数组中的索引位置也发生了变化，所以没有找到其位置上元素，删除失败。</li>
<li>2⃣️：与1同理，可以添加</li>
<li>3⃣️：添加3的时候，首先根据hash值分配到最初a1元素所在位置，然后通过比较两者hash值不同，存入链表。</li>
</ul>
<h2 id="6-map的使用">6. Map的使用</h2>
<h3 id="61-map接口介绍">6.1 Map接口介绍</h3>
<p>Map存储的是上列数据，存储key-value对的数据，类似于高中的函数：y=f(x)。</p>
<p>Map接口的主要实现类包括：HashMap、TreeMap、Hashtable等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown">Map
|--HashMap:Map主要实现类，线程不安全、效率高，可以存储null的key和value值
|		|--LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。
|		|									原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元
|	  |										  素，对于频繁的遍历操作，此类的执行效率高于HashMap								
|--TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序和定制排序，底层 
|					 用的是红黑树。
|--Hashtable:作为古老实现类，线程安全，效率低；不能存储null的key和value值。
|		|--Properties:常用来处理配置文件。key和value都是String类型的。
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>HashMap的底层：数组+链表              （jdk7之前）</p>
<p>​										数组+链表+红黑树（jdk8之后）</p>
</blockquote>
<h3 id="62-map涉及到的面试题">6.2 Map涉及到的面试题</h3>
<ul>
<li><strong>HashMap的底层实现原理？【高频】</strong></li>
<li>HashMap和Hashtable的异同？</li>
<li>CurrentHashMap和Hashtable的异同？</li>
</ul>
<h3 id="63-存储结构的理解">6.3 存储结构的理解</h3>
<p><img src="http://cdn.bearkchan.top/image-20210123001654436.png" alt="image-20210123001654436"></p>
<ul>
<li>
<p>Map中的key：无序的，不可重复的，使用Set存储所有的key。</p>
<blockquote>
<p>key所在的类要重写equals()和hashCode()方法。【以HashMap为例】</p>
</blockquote>
</li>
<li>
<p>Map中的value：无序的，可重复的，使用Collection存储所有的value。</p>
<blockquote>
<p>value所在的类要重写equals()方法。</p>
</blockquote>
</li>
<li>
<p>Map中的entry：一个key-value组成了一个entry，是无序的，不可重复的，使用Set存储所有的entry。</p>
</li>
</ul>
<h3 id="64-map接口常用方法">6.4 Map接口常用方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">-</span> 添加、删除、修改操作：
<span class="k">-</span> Object put(Object key, Object value):将指定key-value添加到(或修改)当前map对象中
<span class="k">-</span> void putAll(Map m):将m中的所有key-value对存放到当前map中。【如果m中有key和当前map对象中key相同，则修改现有的value值为m中的value值】
<span class="k">-</span> Object remove(Object key):移除指定key的key-value对，并返回value
<span class="k">-</span> void clear():清空当前map中的所有数据[并非将map对象设为null，而是将底层数组元素全设为null]

<span class="k">-</span> 元素查询的操作：
<span class="k">-</span> Object get(Object key)：获取指定key对应的value
<span class="k">-</span> boolean containsKey(Object key)：是否包含指定的key 
<span class="k">-</span> boolean containsValue(Object value)：是否包含指定的value 
<span class="k">-</span> int size()：返回map中key-value对的个数 
<span class="k">-</span> boolean isEmpty()：判断当前map是否为空 
<span class="k">-</span> boolean equals(Object obj)：判断当前map和参数对象obj是否相等

<span class="k">-</span> 元视图操作的方法：
<span class="k">-</span> Set keySet()：返回所有key构成的Set集合
<span class="k">-</span> Collection values()：返回所有value构成的Collection集合
<span class="k">-</span> Set entrySet()：返回所有key-value对构成的Set集合
</code></pre></td></tr></table>
</div>
</div><p>上述方法总结：</p>
<ul>
<li>增：put(Object key, Object value)</li>
<li>删：remove(Object key)</li>
<li>改：put(Object key, object value)</li>
<li>查：get(Object key)</li>
<li>长度：size()</li>
<li>遍历：keySet()/values()/entrySet()</li>
</ul>
<h3 id="65-遍历map的三种方式">6.5 遍历Map的三种方式</h3>
<ul>
<li>
<p>使用keySet()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span><span class="s">&#34;zhangsan&#34;</span><span class="o">);</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">,</span><span class="n">12</span><span class="o">);</span>
<span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
<span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
  <span class="n">Object</span> <span class="n">key</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;value = &#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用values()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;zhangsan&#34;</span><span class="o">);</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">,</span> <span class="n">12</span><span class="o">);</span>
<span class="n">Collection</span> <span class="n">values</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="na">values</span><span class="o">();</span>
<span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
  <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;value = &#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>使用entrySet()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;zhangsan&#34;</span><span class="o">);</span>
<span class="n">map1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">,</span> <span class="n">12</span><span class="o">);</span>
<span class="n">Set</span> <span class="n">set</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="na">entrySet</span><span class="o">();</span>
<span class="n">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
  <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span><span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">Object</span> <span class="n">key</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
  <span class="n">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;key = &#34;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&#34;,value = &#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="66-hashmap的底层实现原理">6.6 HashMap的底层实现原理</h3>
<ul>
<li>
<p><strong>在jdk7中</strong></p>
<p><code>HashMap map = new HashMap();</code></p>
<p>在实例化之后，底层创建了长度为16的一维数组Entry[] table。</p>
<p><code>......可能已经执行过多次put......</code></p>
<p><code>map.put(Object key1, Object value1);</code></p>
<p>首先调用key1所在类的hashCode()方法计算key1的哈希值，此哈希值经过某种算法后，得到在Entry[] table数组中的存放索引位置：</p>
<ul>
<li>
<p>如果此位置上的数据为空， 此时的key1-value1添加成功. &mdash;&mdash;情况1⃣️</p>
</li>
<li>
<p>如果此位置上的数据不为空（意味着此位置上存在一个或多个以链表的方式存在的数据），比较key1和已存在的一个或多个数据的哈希值：</p>
<ul>
<li>如果key1的哈希值与已存在的数据的哈希值都不相同，此时的key1-value1添加成功。 &mdash;-情况2⃣️</li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，则继续比较：调用key1所在类的equals(key2)方法，比较：
<ul>
<li>如果equals()返回false：此时key1-value1添加成功。 &mdash;情况3⃣️</li>
<li>如果equals()返回true：此时value1替换value2.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>补充：关于情况2⃣️和3⃣️，此时的key1-value1和原来的数据以链表的方式存储。存储规则是七上八下。</p>
</blockquote>
<p>在不断的添加过程中，会涉及到扩容问题，<strong>当超出临界值且要存放的位置不为空的时候</strong>，扩容。默认的扩容机制是原来的2倍，并将原来的数据复制过来。</p>
<p><img src="http://cdn.bearkchan.top/image-20210123103958081.png" alt="image-20210123103958081"></p>
</li>
<li>
<p><strong>在jdk8中</strong></p>
<p>HashMap在jdk8中相较于jdk7在底层实现方面的不同有：</p>
<ol>
<li>new HashMap():底层没有创建一个长度为16的数组</li>
<li>jdk8底层的数组是：Node[]，而不是Entry[]</li>
<li>首次调用put()方法时，底层创建长度为16的数组</li>
<li>jdk7底层结构为：数组+链表。jdk8中底层结构为：数组+链表+红黑树。
<ul>
<li>形成链表时：七上八下（jdk7中新元素指向旧元素。jdk8中旧的元素指向新的元素。）</li>
<li>当数组的某一个索引位置上的元素以链表的形式存在的数据个数&gt;=8且当前数组的元素个数超过64个时，此时该索引位置上的所有数据改为使用红黑树存储。</li>
</ul>
</li>
</ol>
<p><img src="http://cdn.bearkchan.top/image-20210123103939608.png" alt="image-20210123103939608"></p>
</li>
</ul>
<h3 id="67-hashmap底层典型属性的说明">6.7 HashMap底层典型属性的说明</h3>
<ul>
<li>
<p><code>DEFAULT_INITIAL_CAPACITY </code>: HashMap的默认容量，16</p>
</li>
<li>
<p>MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30</p>
</li>
<li>
<p><code>DEFAULT_LOAD_FACTOR</code>：HashMap的默认加载因子 0.75f</p>
</li>
<li>
<p><code>TREEIFY_THRESHOLD</code>：Bucket中链表长度大于该默认值，转化为红黑树 8</p>
</li>
<li>
<p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</p>
</li>
<li>
<p><code>MIN_TREEIFY_CAPACITY</code>：桶中的Node被树化时最小的hash表容量。64（当桶中Node的 数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍。）</p>
</li>
<li>
<p>table：存储元素的数组，总是2的n次幂</p>
</li>
<li>
<p>entrySet：存储具体元素的集</p>
</li>
<li>
<p>size：HashMap中存储的键值对的数量</p>
</li>
<li>
<p>modCount：HashMap扩容和结构改变的次数。</p>
</li>
<li>
<p>threshold：扩容的临界值，=容量*填充因子  默认是12</p>
</li>
<li>
<p>loadFactor：填充因子</p>
<blockquote>
<p><strong>[面试题]：负载因子loadFactor值的大小，对HashMap有什么影响？</strong></p>
<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的 几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性 能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="68-linkedhashmap底层源码解析了解">6.8 LinkedHashMap底层源码解析（了解）</h3>
<p>LinkedHashMap与HashMap底层源码没有什么区别。原因在于LinkedHashMap本身就继承于HashMap。<strong>唯一的区别在于：LinkedHashMap使用Entry替代了HashMap使用的Node。这使得LinkedHashMap在遍历的时候，可以按照添加的顺序读取数据。</strong></p>
<p>HashMap中的Node的数据结构为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span> 
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span> 
  <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span> 
  <span class="n">V</span> <span class="n">value</span><span class="o">;</span> 
  <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LinkedHashMap中Entry的数据结构为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashMap</span><span class="o">.</span><span class="na">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span> 
  <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">;</span> 
  <span class="n">Entry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span> 
    <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span> 
  <span class="o">}</span> 
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="69-treemap的使用">6.9 TreeMap的使用</h3>
<p>向TreeMap中添加key-value，要求key必须是同一个类的对象。因为要使用key进行排序：自然排序和定制排序。</p>
<p>TreeMap可以保证所有的key-value对处于有序的状态。它的底层使用<strong>红黑树结构</strong>存储数据。</p>
<h3 id="610-使用properties读取配置文件">6.10 使用Properties读取配置文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.bk.collection</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * Create by bear
</span><span class="cm"> * Date 2021/1/23 11:06 上午
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PropertiesTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 默认在项目的根目录下存放source.properties文件
</span><span class="c1"></span>            <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;source.properties&#34;</span><span class="o">);</span>
            <span class="n">Properties</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
            <span class="n">properties</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">age</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&#34;age&#34;</span><span class="o">);</span>
            <span class="n">Integer</span> <span class="n">ageInt</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;name = &#34;</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;ageInt = &#34;</span> <span class="o">+</span> <span class="n">ageInt</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="7-collections的使用">7. Collections的使用</h2>
<p>Collections是用来操作Collection和Map的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<p>Collections中常用方法有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">-</span> 排序操作
<span class="k">-</span> reverse(List list)：反转List中元素的顺序 
<span class="k">-</span> shuffle(List list)：对List集合元素进行随机排序 
<span class="k">-</span> sort(List list)：根据元素的自然顺序对指定List集合元素按升序排序 
<span class="k">-</span> sort(List list，Comparator comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序 
<span class="k">-</span> swap(List list，int i， int j)：将指定list集合中的i处元素和j处元素进行交换

<span class="k">-</span> 查找、替换
<span class="k">-</span> Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素  
<span class="k">-</span> Object max(Collection，Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素  
<span class="k">-</span> Object min(Collection)  
<span class="k">-</span> Object min(Collection，Comparator)  
<span class="k">-</span> int frequency(Collection，Object)：返回指定集合中指定元素的出现次数  
<span class="k">-</span> ⭐️void copy(List dest,List src)：将src中的内容复制到dest中  
<span class="k">-</span> boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List 对象的所有旧值
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>对于copy方法，要求dest不能比src的元素个数小，否则则会报错。</p>
</blockquote>
<p>⚠️注意：</p>
<p><strong>Collections同时还提供了一套线程安全的函数，可以帮助我们将ArrayList、HashMap等线程不安全的集合和Map转换成线程安全的。使用方法为：synchronizedList(List list)和synchronizedMap(Map map)。</strong></p>
<p><img src="http://cdn.bearkchan.top/image-20210123112254598.png" alt="image-20210123112254598"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Bearkchan</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-11
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">java</a>
          <a href="/tags/%E9%9B%86%E5%90%88/">集合</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/java%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/003-string%E7%9B%B8%E5%85%B3%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java中String相关类的使用</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9F%A5%E8%AF%86/002-gitlab%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/">
            <span class="next-text nav-default">gitlab与gitflow结合使用流程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:bearkchan@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/bearkchan" class="iconfont icon-github" title="github"></a>
  <a href="https://bearkchan.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>Bearkchan-<a href='https://beian.miit.gov.cn'>苏ICP备2020053789号</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
